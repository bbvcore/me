"use strict";(self.webpackChunkmydocs=self.webpackChunkmydocs||[]).push([[3083],{8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>t});var a=r(6540);const s={},i=a.createContext(s);function o(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),a.createElement(i.Provider,{value:n},e.children)}},8970:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>t,default:()=>p,frontMatter:()=>o,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"OT/Pr\xe1cticas/siemens-iot-2040","title":"Liber\xedas en Siemens IoT2040","description":"128214; S7 comm y OPCua en Siemens IoT 2040","source":"@site/docs/OT/Pr\xe1cticas/siemens-iot-2040.md","sourceDirName":"OT/Pr\xe1cticas","slug":"/OT/Pr\xe1cticas/siemens-iot-2040","permalink":"/me/docs/docs/OT/Pr\xe1cticas/siemens-iot-2040","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/OT/Pr\xe1cticas/siemens-iot-2040.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Liber\xedas en Siemens IoT2040","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Node-red","permalink":"/me/docs/docs/OT/IIOT/node-red"},"next":{"title":"Cross Compilation","permalink":"/me/docs/docs/OT/Pr\xe1cticas/cross-compilation"}}');var s=r(4848),i=r(8453);const o={title:"Liber\xedas en Siemens IoT2040",sidebar_position:1},t="\ud83d\udcd6 S7 comm y OPCua en Siemens IoT 2040",l={},c=[{value:"\ud83d\udcce Descarga de librer\xedas necesarias",id:"-descarga-de-librer\xedas-necesarias",level:2},{value:"\ud83d\udcc2 Compilaci\xf3n para i386/i586",id:"-compilaci\xf3n-para-i386i586",level:2},{value:"\u2699 Generaci\xf3n de un .whl compatible",id:"-generaci\xf3n-de-un-whl-compatible",level:3},{value:"\u2192 Snap7",id:"-snap7",level:4},{value:"\u2192 OPCua",id:"-opcua",level:4},{value:"\ud83d\udcc3 Copia de las librer\xedas descargadas",id:"-copia-de-las-librer\xedas-descargadas",level:3},{value:"\ud83d\udcca Instalar las librer\xedas descargadas",id:"-instalar-las-librer\xedas-descargadas",level:3},{value:"\u25b6 Python3-snap7 (v. 1.3)",id:"-python3-snap7-v-13",level:4},{value:"Librer\xeda libsnap7",id:"librer\xeda-libsnap7",level:4},{value:"Caso de uso S7",id:"caso-de-uso-s7",level:2},{value:"En tu dispositivo IOT2000:",id:"en-tu-dispositivo-iot2000",level:3},{value:"Descargar versi\xf3n compatible con GLIBC 2.31",id:"descargar-versi\xf3n-compatible-con-glibc-231",level:3},{value:"Verificar compatibilidad",id:"verificar-compatibilidad",level:3},{value:"Actualizar cache",id:"actualizar-cache",level:3},{value:"Servidor S7 funcionando con Python puro",id:"servidor-s7-funcionando-con-python-puro",level:3},{value:"Cliente s7 puro",id:"cliente-s7-puro",level:2},{value:"Compatibilidad de la librer\xeda",id:"compatibilidad-de-la-librer\xeda",level:2},{value:"An\xe1lisis binario de la librer\xeda",id:"an\xe1lisis-binario-de-la-librer\xeda",level:3},{value:"An\xe1lisis hexadecimal de la librer\xeda",id:"an\xe1lisis-hexadecimal-de-la-librer\xeda",level:3},{value:"\u25b6 OPCUA",id:"-opcua-1",level:4},{value:"\ud83d\udce5 Comando de instalaci\xf3n",id:"-comando-de-instalaci\xf3n",level:4},{value:"\ud83d\udd0d Comprobaciones",id:"-comprobaciones",level:2},{value:"\u2705 Verificaci\xf3n",id:"-verificaci\xf3n",level:3},{value:"\u26a0\ufe0f  Solucionar el Warning",id:"warning--solucionar-el-warning",level:3},{value:"\u23f1 Verificado",id:"-verificado",level:2},{value:"Caso de uso OPCUA",id:"caso-de-uso-opcua",level:2},{value:"Servidor OPCUA",id:"servidor-opcua",level:3},{value:"Cliente OPCUA",id:"cliente-opcua",level:3},{value:"Anexo: problemas Siemens IoT20240",id:"anexo-problemas-siemens-iot20240",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"-s7-comm-y-opcua-en-siemens-iot-2040",children:"\ud83d\udcd6 S7 comm y OPCua en Siemens IoT 2040"})}),"\n",(0,s.jsxs)(n.p,{children:["Lo primero de todo, es que es necesario tener ",(0,s.jsx)(n.strong,{children:"Python"})," instalado en el equipo, en este caso se comprueba su disponibilidad una vez se accede por ",(0,s.jsx)(n.strong,{children:"SSH"})," al dispositivo de Siemens."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"python3 --version\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Se comrpueba positivamente que Python viene instalado de serie en la imagen y es la versi\xf3n ",(0,s.jsx)(n.strong,{children:"3.18.13"}),", no viene instalado ",(0,s.jsx)(n.strong,{children:"pip/pip3"})," y sumado a que la versi\xf3n de Yocto generada para el despliegue no dispone de gestor de dependencias toca descargar en otro equipo las librer\xedas necesarias."]}),"\n",(0,s.jsx)(n.h2,{id:"-descarga-de-librer\xedas-necesarias",children:"\ud83d\udcce Descarga de librer\xedas necesarias"}),"\n",(0,s.jsx)(n.p,{children:"En este caso toca recurrir a la b\xfasqueda de las mismas en el dominio siguiente."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"https://pypi.org\n"})}),"\n",(0,s.jsx)(n.p,{children:"A continuaci\xf3n se va a buscar las librer\xedas *.whl precompiladas para la arquitectura requerida seg\xfan el hardware del dispositivo."}),"\n",(0,s.jsx)(n.p,{children:"Las librer\xedas descargadas se obtienen como un tarball y son necesarias para ser compatibles con Python 3.8.13 y no tener problemas las siguientes versiones:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"python-snap7 1.3"}),"\n",(0,s.jsx)(n.li,{children:"opcua 0.98.12"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Una vez descargadas hace falta compilarlas acorde a la arquitectura del Siemenes IoT 2040, para ello hace falta preparar el host donde se van a compilar de la siguiente manera."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"sudo apt update\nsudo apt install -y build-essential python3-dev python3-pip python3-wheel libssl-dev\n"})}),"\n",(0,s.jsx)(n.h2,{id:"-compilaci\xf3n-para-i386i586",children:"\ud83d\udcc2 Compilaci\xf3n para i386/i586"}),"\n",(0,s.jsx)(n.h3,{id:"-generaci\xf3n-de-un-whl-compatible",children:"\u2699 Generaci\xf3n de un .whl compatible"}),"\n",(0,s.jsx)(n.h4,{id:"-snap7",children:"\u2192 Snap7"}),"\n",(0,s.jsx)(n.p,{children:"Se espec\xedfica la arquitectura accediendo al directorio descomprimido y ejecutando, dentro de python-snap7-1.0."}),"\n",(0,s.jsx)(n.admonition,{title:"Cross-compilation",type:"tip",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'CFLAGS="-march=i586" python3 setup.py bdist_wheel --plat-name=linux_i586\n'})})}),"\n",(0,s.jsxs)(n.p,{children:["Se obtiene en ",(0,s.jsx)(n.strong,{children:"/dist"})," un fichero whl para exportar al siemens IoT."]}),"\n",(0,s.jsx)(n.h4,{id:"-opcua",children:"\u2192 OPCua"}),"\n",(0,s.jsx)(n.p,{children:"En este caso se genera directamente una vez se est\xe1 dentro del directorio descomprimido con el comando."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"pithon3 setup.py bdist_wheel\n"})}),"\n",(0,s.jsx)(n.p,{children:"Y dentro del directorio /dist se genera la liber\xeda whl."}),"\n",(0,s.jsx)(n.h3,{id:"-copia-de-las-librer\xedas-descargadas",children:"\ud83d\udcc3 Copia de las librer\xedas descargadas"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"scp *.whl root@192.168.200.1:/home/root\n"})}),"\n",(0,s.jsx)(n.h3,{id:"-instalar-las-librer\xedas-descargadas",children:"\ud83d\udcca Instalar las librer\xedas descargadas"}),"\n",(0,s.jsx)(n.h4,{id:"-python3-snap7-v-13",children:"\u25b6 Python3-snap7 (v. 1.3)"}),"\n",(0,s.jsx)(n.p,{children:"Instalaci\xf3n de la librer\xeda para S7."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"python3 -m pip install --user --no-index --find-links=/home/root python3_snap7-1.3-pyp3-none-linux_i586.whl\n"})}),"\n",(0,s.jsx)(n.h4,{id:"librer\xeda-libsnap7",children:"Librer\xeda libsnap7"}),"\n",(0,s.jsx)(n.p,{children:"cd ~/cross-compilation/libsnap/snap7-full-1.4.2/"}),"\n",(0,s.jsx)(n.p,{children:"Compilaci\xf3n"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"g++ -m32 -march=i586 -shared -fPIC \\\n-Irelease/Wrappers/c-cpp \\\n-Isrc/sys \\\n-Isrc/core \\\n-Isrc/lib \\\n-Isrc \\\nsrc/sys/snap_msgsock.cpp \\\nsrc/sys/snap_threads.cpp \\\nsrc/sys/snap_tcpsrvr.cpp \\\nsrc/sys/snap_sysutils.cpp \\\nsrc/core/s7_peer.cpp \\\nsrc/core/s7_server.cpp \\\nsrc/core/s7_text.cpp \\\nsrc/core/s7_client.cpp \\\nsrc/core/s7_partner.cpp \\\nsrc/core/s7_micro_client.cpp \\\nsrc/core/s7_isotcp.cpp \\\nsrc/lib/snap7_libmain.cpp \\\n-o build/bin/i386_linux/libsnap7.so\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsx)(n.p,{children:"-Isrc/sys: Agrega la ruta de ficheros de sistema\n-Isrc/core: Agrega la ruta de ficheros del nucleo\n-Isrc/lib: Agrega de los ficheros de librer\xeda\n-Isrc: Ruta base como respaldo adicional"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Comprobaci\xf3n de la librer\xeda"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"file build/bin/i386_linux/libsnap7.so\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Resultado de la comprobaci\xf3n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"libsnap7.so: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), statically linked, BuildID[sha1]=06d7151d3f0a65664efc5ca072f022e694aeb5a4, not stripped\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Copiar librer\xeda"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"cp libsnap7.so /usr/lib/\nchmod 755 /usr/lib/libsnap7.so\nldconfig # Actualizar librer\xedas\nldconfig -p | grep libsnap7\n"})}),"\n",(0,s.jsx)(n.h2,{id:"caso-de-uso-s7",children:"Caso de uso S7"}),"\n",(0,s.jsx)(n.p,{children:"Se va a probar con un servidor y un cliente para testear correctamente snap7."}),"\n",(0,s.jsx)(n.p,{children:"Al comprobar la librer\xeda se produce un error por la versi\xf3n GCC de la compilaci\xf3n entonces se va a realizar estos pasos:"}),"\n",(0,s.jsx)(n.h3,{id:"en-tu-dispositivo-iot2000",children:"En tu dispositivo IOT2000:"}),"\n",(0,s.jsx)(n.p,{children:"cd /usr/lib\nmv libsnap7.so libsnap7.so.backup  # Hacer backup"}),"\n",(0,s.jsx)(n.h3,{id:"descargar-versi\xf3n-compatible-con-glibc-231",children:"Descargar versi\xf3n compatible con GLIBC 2.31"}),"\n",(0,s.jsxs)(n.p,{children:["wget ",(0,s.jsx)(n.a,{href:"https://github.com/SCADACS/PLCinject/raw/master/snap7/release/Linux/i386/glibc_2.21/libsnap7.so",children:"https://github.com/SCADACS/PLCinject/raw/master/snap7/release/Linux/i386/glibc_2.21/libsnap7.so"})]}),"\n",(0,s.jsx)(n.h3,{id:"verificar-compatibilidad",children:"Verificar compatibilidad"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"objdump -T libsnap7.so | grep GLIBC_\n\nfile libsnap7.so \nlibsnap7.so: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically linked, BuildID[sha1]=de167e5ce2c0a447ae57d4747e49d3bcd100c763, not stripped\n"})}),"\n",(0,s.jsx)(n.h3,{id:"actualizar-cache",children:"Actualizar cache"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Copiar la librer\xeda libsnap7.so al yocto\nldconfig\n"})}),"\n",(0,s.jsx)(n.admonition,{title:"Necesario Python puro",type:"warning",children:(0,s.jsx)(n.p,{children:"Ahora la librer\xeda es la correcta, con la versi\xf3n de gcc correcta, pero contiene instrucciones que el Atom del IOT2040 no maneja y el mensaje del server es ilegal instruction, la librer\xeda que pod\xeda valer no se puede descargar por error 404 entonces la \xfanica forma de hacerlo funcionar es con python puro."})}),"\n",(0,s.jsx)(n.h3,{id:"servidor-s7-funcionando-con-python-puro",children:"Servidor S7 funcionando con Python puro"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'import socket\nimport struct\nimport time\nimport threading\nimport select\nimport sys\nimport signal\nimport datetime\n\nclass Snap7Server:\n    def __init__(self, port=1102):\n        self.port = port\n        self.running = False\n        self.db = {1: bytearray(128)}  # DB1 con 128 bytes\n        self.mb = bytearray(1024)      # Memoria de marca\n        self.eb = bytearray(1024)      # Entradas\n        self.ab = bytearray(1024)      # Salidas\n        self.last_activity = time.time()\n        self.init_db_data()\n        \n    def init_db_data(self):\n        """Inicializa DB1 con valores predeterminados"""\n        # Valores iniciales para DB1\n        struct.pack_into(\'>h\', self.db[1], 0, 1234)    # DB1.DBW0\n        struct.pack_into(\'>f\', self.db[1], 4, 3.14159) # DB1.DBD4\n        self.db[1][8] = self.db[1][8] | 0x01           # DB1.DBX8.0\n        \n        print("Valores iniciales configurados:")\n        print(f"  DB1.DBW0: {struct.unpack(\'>h\', self.db[1][0:2])[0]}")\n        print(f"  DB1.DBD4: {struct.unpack(\'>f\', self.db[1][4:8])[0]:.5f}")\n        print(f"  DB1.DBX8.0: {bool(self.db[1][8] & 0x01)}")\n        \n    def handle_client(self, conn, addr):\n        """Maneja las conexiones de clientes"""\n        client_id = f"{addr[0]}:{addr[1]}"\n        print(f"[{client_id}] Cliente conectado")\n        \n        try:\n            while self.running:\n                # Usar select para manejar m\xfaltiples clientes\n                ready, _, _ = select.select([conn], [], [], 1.0)\n                if not ready:\n                    continue\n                \n                # Recibir cabecera (12 bytes)\n                header = conn.recv(12)\n                if len(header) < 12:\n                    break\n                    \n                # Decodificar cabecera\n                try:\n                    function, area, db_number, data_type, start, amount = struct.unpack(\'>B B B B H H\', header)\n                except struct.error:\n                    print(f"[{client_id}] Cabecera inv\xe1lida")\n                    break\n                \n                # Procesar solicitud\n                if function == 4:  # Lectura\n                    data = self.read_area(area, db_number, start, amount)\n                    if data is not None:\n                        conn.sendall(data)\n                        self.last_activity = time.time()\n                elif function == 5:  # Escritura\n                    data = conn.recv(amount)\n                    if len(data) == amount:\n                        success = self.write_area(area, db_number, start, data)\n                        conn.sendall(b\'\\x00\' if success else b\'\\xFF\')\n                        self.last_activity = time.time()\n                else:\n                    print(f"[{client_id}] Funci\xf3n desconocida: {function}")\n                    conn.sendall(b\'\\xFF\')  # NACK\n        except ConnectionResetError:\n            print(f"[{client_id}] Conexi\xf3n cerrada por el cliente")\n        except Exception as e:\n            print(f"[{client_id}] Error: {str(e)}")\n        finally:\n            conn.close()\n            print(f"[{client_id}] Desconectado")\n\n    def read_area(self, area, db_number, start, amount):\n        """Lee datos de las \xe1reas"""\n        try:\n            if area == 0x84:  # DB\n                if db_number in self.db:\n                    data = self.db[db_number]\n                    end = min(start + amount, len(data))\n                    return data[start:end]\n            elif area == 0x83:  # MB\n                end = min(start + amount, len(self.mb))\n                return self.mb[start:end]\n            elif area == 0x81:  # EB\n                end = min(start + amount, len(self.eb))\n                return self.eb[start:end]\n            elif area == 0x82:  # AB\n                end = min(start + amount, len(self.ab))\n                return self.ab[start:end]\n            return bytearray()\n        except Exception:\n            return None\n            \n    def write_area(self, area, db_number, start, data):\n        """Escribe datos en las \xe1reas"""\n        try:\n            if area == 0x84:  # DB\n                if db_number in self.db:\n                    db_data = self.db[db_number]\n                    end = min(start + len(data), len(db_data))\n                    db_data[start:end] = data[:end-start]\n                    return True\n            elif area == 0x83:  # MB\n                end = min(start + len(data), len(self.mb))\n                self.mb[start:end] = data[:end-start]\n                return True\n            elif area == 0x81:  # EB\n                end = min(start + len(data), len(self.eb))\n                self.eb[start:end] = data[:end-start]\n                return True\n            elif area == 0x82:  # AB\n                end = min(start + len(data), len(self.ab))\n                self.ab[start:end] = data[:end-start]\n                return True\n            return False\n        except Exception:\n            return False\n\n    def start(self):\n        """Inicia el servidor"""\n        self.running = True\n        self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        self.server.bind((\'0.0.0.0\', self.port))\n        self.server.listen(5)\n        print(f"Servidor Snap7 en Python iniciado en puerto {self.port}")\n        print(f"Fecha: {datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S\')}")\n        print("\xc1reas disponibles:")\n        print(" - DB1 (128 bytes)")\n        print(" - MB (1024 bytes)")\n        print(" - EB (1024 bytes)")\n        print(" - AB (1024 bytes)")\n        print("Presiona Ctrl+C para detener...")\n        \n        try:\n            while self.running:\n                conn, addr = self.server.accept()\n                conn.settimeout(5.0)\n                thread = threading.Thread(target=self.handle_client, args=(conn, addr))\n                thread.daemon = True\n                thread.start()\n        except OSError:\n            pass  # Servidor detenido\n        finally:\n            self.server.close()\n\n    def stop(self):\n        """Detiene el servidor"""\n        if self.running:\n            print("Deteniendo servidor...")\n            self.running = False\n            # Desbloquear el accept()\n            try:\n                temp_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                temp_sock.connect((\'127.0.0.1\', self.port))\n                temp_sock.close()\n            except:\n                pass\n            print("Servidor detenido")\n\n# Manejo de se\xf1ales para Ctrl+C\ndef handle_sigint(signum, frame):\n    print("\\nSe\xf1al SIGINT recibida, deteniendo servidor...")\n    server.stop()\n    sys.exit(0)\n\nif __name__ == \'__main__\':\n    server = Snap7Server(1102)\n    signal.signal(signal.SIGINT, handle_sigint)\n    \n    try:\n        server.start()\n    except Exception as e:\n        print(f"Error cr\xedtico: {str(e)}")\n        server.stop()\n        sys.exit(1)\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Este ",(0,s.jsx)(n.strong,{children:"servidor puro"})," realizado en ",(0,s.jsx)(n.strong,{children:"Python"})," posee las siguientes caracter\xedsticas:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Es ",(0,s.jsx)(n.strong,{children:"totalmente compatible"})," con Python al ",(0,s.jsx)(n.strong,{children:"100%"})," sin necesidad de dependencias externas."]}),"\n",(0,s.jsxs)(n.li,{children:["Incorpora soporte completo para \xe1reas de memoria: ",(0,s.jsx)(n.strong,{children:"DB"})," ",(0,s.jsx)(n.em,{children:"(bloque de datos)"}),",",(0,s.jsx)(n.strong,{children:"MD"})," ",(0,s.jsx)(n.em,{children:"(memoria de marca)"}),", ",(0,s.jsx)(n.strong,{children:"EB"})," ",(0,s.jsx)(n.em,{children:"(entradas)"})," y ",(0,s.jsx)(n.strong,{children:"AB"})," ",(0,s.jsx)(n.em,{children:"(salidas)"})]}),"\n",(0,s.jsxs)(n.li,{children:["Compatible con clientes ",(0,s.jsx)(n.strong,{children:"Snap7"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Adem\xe1s aporta una seri de ventajas sobre la librer\xeda desarrollada en ",(0,s.jsx)(n.strong,{children:"C++"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Elimina problemas de compatibilidad"}),"\n",(0,s.jsx)(n.li,{children:"No tiene dependencias con bibliotecas externas"}),"\n",(0,s.jsx)(n.li,{children:"Es m\xe1s f\xe1cil de depurar al estar integramente en Python"}),"\n",(0,s.jsx)(n.li,{children:"Menor consumo de recursos en sistemas embebidos como el caso del Yocto"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"cliente-s7-puro",children:"Cliente s7 puro"}),"\n",(0,s.jsx)(n.p,{children:"Este c\xf3digo se ejecuta en otro host diferente al Siemens IoT 2040 pero dentro de la misma LAN"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'import socket\nimport struct\nimport sys\nimport time\n\nclass Snap7Client:\n    def __init__(self, ip=\'192.168.200.1\', port=1102):\n        self.ip = ip\n        self.port = port\n        self.sock = None\n        self.connected = False\n        \n    def connect(self):\n        """Conecta al servidor con manejo detallado de errores"""\n        print(f"Conectando a {self.ip}:{self.port}...")\n        try:\n            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            self.sock.settimeout(5.0)\n            self.sock.connect((self.ip, self.port))\n            self.connected = True\n            print("\xa1Conexi\xf3n TCP exitosa!")\n            return True\n        except ConnectionRefusedError:\n            print("Error: Conexi\xf3n rechazada. Verifica:")\n            print("1. Que el servidor est\xe9 en ejecuci\xf3n")\n            print("2. Que la IP y puerto sean correctos")\n            return False\n        except socket.timeout:\n            print("Error: Tiempo de espera agotado. Verifica:")\n            print("1. Que el dispositivo est\xe9 encendido")\n            print("2. Que la IP sea correcta")\n            print("3. Que no haya problemas de red")\n            return False\n        except Exception as e:\n            print(f"Error de conexi\xf3n: {str(e)}")\n            return False\n        \n    def disconnect(self):\n        """Desconecta del servidor"""\n        if self.sock:\n            self.sock.close()\n            self.connected = False\n            print("Desconectado")\n        \n    def read_db(self, db_number, start, size):\n        """Lee datos de DB con depuraci\xf3n mejorada"""\n        if not self.connected:\n            print("Error: No conectado al servidor")\n            return None\n            \n        try:\n            # Cabecera: funci\xf3n, \xe1rea, db_number, tipo, start, size\n            header = struct.pack(\'>BBBBHH\', 4, 0x84, db_number, 0, start, size)\n            print(f"[DEBUG] Enviando cabecera: {header.hex()}")\n            \n            self.sock.sendall(header)\n            \n            # Recibir datos con timeout\n            data = bytearray()\n            start_time = time.time()\n            \n            while len(data) < size:\n                remaining = size - len(data)\n                try:\n                    chunk = self.sock.recv(remaining)\n                    if not chunk:\n                        print("Error: Conexi\xf3n cerrada por el servidor")\n                        return None\n                    data.extend(chunk)\n                except socket.timeout:\n                    if time.time() - start_time > 4.0:\n                        print(f"Error: Tiempo de espera agotado. Recibidos {len(data)}/{size} bytes")\n                        return None\n            \n            print(f"[DEBUG] Datos recibidos: {data.hex()}")\n            print(f"[DEBUG] Tama\xf1o recibido: {len(data)} bytes")\n            return data\n            \n        except Exception as e:\n            print(f"Error en lectura: {str(e)}")\n            return None\n        \n    def write_db(self, db_number, start, data):\n        """Escribe datos en DB con depuraci\xf3n mejorada"""\n        if not self.connected:\n            print("Error: No conectado al servidor")\n            return False\n            \n        try:\n            # Cabecera de escritura\n            header = struct.pack(\'>BBBBHH\', 5, 0x84, db_number, 0, start, len(data))\n            print(f"[DEBUG] Enviando cabecera: {header.hex()}")\n            print(f"[DEBUG] Enviando datos: {data.hex()}")\n            \n            self.sock.sendall(header + data)\n            \n            # Recibir respuesta\n            response = self.sock.recv(1)\n            print(f"[DEBUG] Respuesta del servidor: {response.hex() if response else \'None\'}")\n            \n            if response == b\'\\x00\':\n                print("Escritura exitosa (confirmaci\xf3n recibida)")\n                return True\n            else:\n                print(f"Error en escritura. C\xf3digo de respuesta: {response.hex() if response else \'Ninguno\'}")\n                return False\n                \n        except Exception as e:\n            print(f"Error en escritura: {str(e)}")\n            return False\n\n\nif __name__ == \'__main__\':\n    # Configuraci\xf3n por defecto\n    server_ip = "192.168.200.1"\n    server_port = 1102\n    \n    # Manejar argumentos de l\xednea de comandos\n    if len(sys.argv) > 1:\n        server_ip = sys.argv[1]\n    if len(sys.argv) > 2:\n        server_port = int(sys.argv[2])\n    \n    print(f"=== Cliente Snap7 Mejorado ===")\n    print(f"Servidor: {server_ip}:{server_port}")\n    print(f"Fecha: 2025-07-04")\n    print(f"====================================\\n")\n    \n    client = Snap7Client(server_ip, server_port)\n    \n    try:\n        if not client.connect():\n            print("\\nSugerencias:")\n            print("1. Verifica que el servidor est\xe9 ejecut\xe1ndose")\n            print("2. Comprueba la IP con \'ping 192.168.200.1\'")\n            print("3. Prueba con el comando: telnet 192.168.200.1 1102")\n            sys.exit(1)\n        \n        # Primera lectura - DBW0 (2 bytes)\n        print("\\n[Prueba 1] Leyendo DB1.DBW0 (2 bytes)...")\n        dbw0_data = client.read_db(1, 0, 2)\n        \n        if dbw0_data and len(dbw0_data) == 2:\n            value = struct.unpack(\'>h\', dbw0_data)[0]\n            print(f"DB1.DBW0 = {value}")\n        else:\n            print("Error: No se pudo leer DBW0")\n            print("Posibles causas:")\n            print("a) DB1 no existe en el servidor")\n            print("b) El offset 0 no es v\xe1lido")\n            print("c) Problema de protocolo")\n        \n        # Segunda lectura - DBD4 (4 bytes)\n        print("\\n[Prueba 2] Leyendo DB1.DBD4 (4 bytes)...")\n        dbd4_data = client.read_db(1, 4, 4)\n        \n        if dbd4_data and len(dbd4_data) == 4:\n            value = struct.unpack(\'>f\', dbd4_data)[0]\n            print(f"DB1.DBD4 = {value:.5f}")\n        else:\n            print("Error: No se pudo leer DBD4")\n        \n        # Escritura de prueba\n        print("\\n[Prueba 3] Escribiendo nuevo valor en DB1.DBW0...")\n        new_value = struct.pack(\'>h\', 5678)\n        \n        if client.write_db(1, 0, new_value):\n            print("Escritura confirmada por servidor")\n            \n            # Verificaci\xf3n\n            print("\\n[Prueba 4] Verificando escritura...")\n            dbw0_data = client.read_db(1, 0, 2)\n            if dbw0_data and len(dbw0_data) == 2:\n                new_dbw0 = struct.unpack(\'>h\', dbw0_data)[0]\n                print(f"Nuevo DB1.DBW0 = {new_dbw0}")\n                if new_dbw0 == 5678:\n                    print("\xa1Escritura verificada correctamente!")\n                else:\n                    print("Error: El valor no coincide")\n            else:\n                print("Error: No se pudo verificar la escritura")\n        else:\n            print("Error: La escritura no fue confirmada por el servidor")\n            print("Posibles causas:")\n            print("a) Permisos insuficientes en el servidor")\n            print("b) Direcci\xf3n inv\xe1lida (DB o offset)")\n            print("c) Error de protocolo")\n        \n    except KeyboardInterrupt:\n        print("\\nOperaci\xf3n cancelada por el usuario")\n    except Exception as e:\n        print(f"\\nError inesperado: {str(e)}")\n        import traceback\n        traceback.print_exc()\n    finally:\n        client.disconnect()\n'})}),"\n",(0,s.jsx)(n.admonition,{title:"Para S7 solo Python puro",type:"warning",children:(0,s.jsxs)(n.p,{children:["Para usar el ",(0,s.jsx)(n.strong,{children:"protocolo S7"})," sobre el sistema Yocto en un ",(0,s.jsx)(n.strong,{children:"Siemens IoT2040"})," usar Python puro dado que las librer\xedas de ",(0,s.jsx)(n.strong,{children:"C++"})," dan problemas por instrucciones que no puede procesar el microprocesador ",(0,s.jsx)(n.strong,{children:"Intel"})," del dispositivo. Adem\xe1s la alternativa, que era usar una librer\xeda ofrecida por el fabricante el enlace esta roto ",(0,s.jsx)(n.em,{children:"(404)"})]})}),"\n",(0,s.jsxs)(n.p,{children:["Como segu\xeda habiendo problemas se comprueba la librer\xeda desde el propio ",(0,s.jsx)(n.strong,{children:"Yocto"})," por si hab\xeda algun problema y todo era aparentemente correcto."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"root@iot2000:~# ldd /usr/lib/libsnap7.so\n\tlinux-gate.so.1 (0xb76e1000)\n\tlibpthread.so.0 => /lib/libpthread.so.0 (0xb7669000)\n\tlibrt.so.1 => /lib/librt.so.1 (0xb765f000)\n\tlibstdc++.so.6 => /usr/lib/libstdc++.so.6 (0xb748b000)\n\tlibgcc_s.so.1 => /lib/libgcc_s.so.1 (0xb746c000)\n\tlibc.so.6 => /lib/libc.so.6 (0xb72c6000)\n\t/lib/ld-linux.so.2 (0xb76e2000)\n\tlibm.so.6 => /lib/libm.so.6 (0xb71c7000)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["El estado de la librer\xeda era perfecto, algo que se esperaba ya que fue descargada de ",(0,s.jsx)(n.a,{href:"https://sourceforge.net/projects/snap7/files/Snap7-IoT/snap7-iot-quark/",children:"https://sourceforge.net/projects/snap7/files/Snap7-IoT/snap7-iot-quark/"})," , siendo oficial para el dispositivo Siemens IoT 2040."]}),"\n",(0,s.jsx)(n.h2,{id:"compatibilidad-de-la-librer\xeda",children:"Compatibilidad de la librer\xeda"}),"\n",(0,s.jsx)(n.h3,{id:"an\xe1lisis-binario-de-la-librer\xeda",children:"An\xe1lisis binario de la librer\xeda"}),"\n",(0,s.jsxs)(n.p,{children:["Pero como segu\xeda dando problemas la ejecuci\xf3n y el error era de ",(0,s.jsx)(n.strong,{children:"instrucci\xf3n ilegal"})," se procede a realizar un an\xe1lisis binariode la misma, para ello se convierte a ",(0,s.jsx)(n.strong,{children:"asm"})," ",(0,s.jsx)(n.em,{children:"(ensamblador)"})," mediante el comando ",(0,s.jsx)(n.strong,{children:"objdump"}),"."]}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"objdump permite inspeccionar el c\xf3digo de archivos binarios ejecutables"}),"\n",(0,s.jsx)(n.li,{children:"d: desensamblar el c\xf3digo m\xe1quina a ensamblador (m\xe1s legible)"}),"\n"]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"objdump -d /usr/lib/libsnap7.so > libsnap7.asm # se obtiene fichero libsnap7.asm\n"})}),"\n",(0,s.jsx)(n.p,{children:"Entonces mediante el uso del comando grep se pueden buscar instrucciones incompatibles en el c\xf3digo con el microprocesador del Siemens Yocto."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"grep -i -E '<instrucciones>' librer\xeda.asm\n"})}),"\n",(0,s.jsx)(n.h3,{id:"an\xe1lisis-hexadecimal-de-la-librer\xeda",children:"An\xe1lisis hexadecimal de la librer\xeda"}),"\n",(0,s.jsxs)(n.p,{children:["Tambi\xe9n se utiliza la herramienta ",(0,s.jsx)(n.strong,{children:"hexdump"})," ",(0,s.jsx)(n.em,{children:"(con par\xe1metro -c)"})," para ver el c\xf3digo hexadecimal del binario en formato hexadecimal y con codificaci\xf3n ASCII"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"root@iot2000:~# hexdump -C /usr/lib/libsnap7.so | grep '66 0f'\n\n0001c1f0  05 00 00 0f 8f 87 02 00  00 83 fa 66 0f 84 ae 05  |...........f....|\n00025170  fe ff 66 0f af 46 10 66  89 44 24 1e 0f b6 47 01  |..f..F.f.D$...G.|\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Consultando se observo que ",(0,s.jsx)(n.strong,{children:"66 0f"})," es un prefijo habitual para la ejecuci\xf3n de instrucciones de tipo ",(0,s.jsx)(n.strong,{children:"SSE/SSE2"})," que incluyen algunas como las siguientes: movupd, addpd, mulpd..."]}),"\n",(0,s.jsxs)(n.p,{children:["Este tipo de instrucciones no se pueden ejecutar en procesadores como el Quark X1000 dado que no existen en el micro y por consiguiente lanzan el mensaje recibido tras la ejecuci\xf3n del script de ",(0,s.jsx)(n.strong,{children:"Illegal instruction"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"-opcua-1",children:"\u25b6 OPCUA"}),"\n",(0,s.jsx)(n.p,{children:"Para opcua hacen falta dependencias como pytz o python-dateutil, que se han de descargar de la siguiente forma y luego pasarlas por ssh con scp al dispositivo IoT de Siemens."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"pip download pytz --platform manylinux1_i586 --python-version 38 --only-binary=:all:\nscp pytz-*.whl root@192.168.200.1:/home/root\npip download python-dateutil --platform any --python-version 38 --no-deps\nscp python_dateutil*.whl root@192.168.200.1:/home/root\n"})}),"\n",(0,s.jsx)(n.p,{children:"Como son varias lo mejor es buscar todas las dependencias que necesita la librer\xeda, para ello se ejecuta el siguiente comando."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"unzip -p opcua-0.98.12-py3-none-any.whl opcua-0.98.12.dist-info/METADATA | grep Requires-Dist\n"})}),"\n",(0,s.jsx)(n.p,{children:"Y se obtiene el listado de las dependencias necesarias."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"lxml >=3.0\npython-dateutil >= 2.1\npytz >= 2011k\ncryptography; extra == 'encryption' >=1.3\n"})}),"\n",(0,s.jsx)(n.p,{children:"A continuaci\xf3n se van a compilar las librer\xedas de lxml y de cryptography, para ello hay que actualizar e instalar los siguientes paquetes"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"sudo apt update\nsudo apt install -y python3-dev libxml2-dev libxslt-dev libssl-dev\nsudo apt install -y libxslt1-dev gcc-multilib  \n"})}),"\n",(0,s.jsx)(n.p,{children:"Las descargas de las librerias y su posterior compilaci\xf3n, una vez se descargaron, se descomprimieron y se accedieron a sus correspondientes directorios descomprimidos."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'pip download lxml --no-binary=lxml\nCFLAGS="-march=i586 -mtune=generic" python3 setup.py bdist_wheel --plat-name=linux_i586\n'})}),"\n",(0,s.jsx)(n.p,{children:"Como la gesti\xf3n de las dependencias y de las librer\xedas se va volviendo complicada, creo una entrada independiente para este cometido."}),"\n",(0,s.jsx)(n.admonition,{title:"Acceso al cross-compilation",type:"warning",children:(0,s.jsx)("a",{href:"cross-compilation.md",children:"Gu\xeda de cross-compilation"})}),"\n",(0,s.jsx)(n.h4,{id:"-comando-de-instalaci\xf3n",children:"\ud83d\udce5 Comando de instalaci\xf3n"}),"\n",(0,s.jsx)(n.p,{children:"Antes de instalar comprobar tener estas librer\xedas en /home/root"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"- six-1.16.0-py2.py3-none-any.whl\n- python_dateutil-2.8.2-py2.py3-none-any.whl\n- pytz-2023.3-py2.py3-none-any.whl\n- lxml-4.9.3-cp38-cp38-linux_i586.whl  \n- cryptography-3.4.8-cp38-cp38-linux_i586.whl\n- opcua-0.98.12-py3-none-any.whl\n"})}),"\n",(0,s.jsx)(n.h2,{id:"-comprobaciones",children:"\ud83d\udd0d Comprobaciones"}),"\n",(0,s.jsx)(n.h3,{id:"-verificaci\xf3n",children:"\u2705 Verificaci\xf3n"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"python3 -c \"import snap7; import opcua; print('El estado de las librer\xedas en el sistema es el correcto')\"\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"oot@iot2000:~# rm cryptography-45.0.4-cp311-abi3-manylinux_2_34_x86_64.whl \nroot@iot2000:~# python3 -m pip install --user --no-index --find-links=/home/root/ six-*.whl python_dateutil-*.whl  pytz-*.whl   opcua-0.98.12-py3-none-any.whl\nLooking in links: /home/root/\nProcessing ./six-1.16.0-py2.py3-none-any.whl\nProcessing ./python_dateutil-2.8.2-py2.py3-none-any.whl\nProcessing ./pytz-2023.3-py2.py3-none-any.whl\nProcessing ./opcua-0.98.12-py3-none-any.whl\nRequirement already satisfied: lxml in /usr/lib/python3.8/site-packages (from opcua==0.98.12) (4.5.0)\nInstalling collected packages: six, python-dateutil, pytz, opcua\n  WARNING: The scripts uabrowse, uacall, uaclient, uadiscover, uahistoryread, uals, uaread, uaserver, uasubscribe and uawrite are installed in '/home/root/.local/bin' which is not on PATH.\n  Consider adding this directory to PATH or, if you prefer to suppress this warning, use --no-warn-script-location.\nSuccessfully installed opcua-0.98.12 python-dateutil-2.8.2 pytz-2023.3 six-1.16.0\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"warning--solucionar-el-warning",children:["\u26a0\ufe0f","  Solucionar el Warning"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"echo 'export PATH=$PATH:/home/root/.local/bin' >> /home/root/.profile\n"})}),"\n",(0,s.jsx)(n.h2,{id:"-verificado",children:"\u23f1 Verificado"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"root@iot2000:~# python3 -c \"import opcua; print('ok')\"\ncryptography is not installed, use of crypto disabled\ncryptography is not installed, use of crypto disabled\nok\nroot@iot2000:~# python3 -c \"import snap7; print('ok')\"\nok\n"})}),"\n",(0,s.jsx)(n.h2,{id:"caso-de-uso-opcua",children:"Caso de uso OPCUA"}),"\n",(0,s.jsx)(n.h3,{id:"servidor-opcua",children:"Servidor OPCUA"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from opcua import Server\nimport time\n\ntry:\n    print("[DEBUG] Creando servidor OPC UA...")\n    server = Server()\n\n    print("[DEBUG] Configurando endpoint a 0.0.0.0:4840...")\n    server.set_endpoint("opc.tcp://0.0.0.0:4840/freeopcua/server/")\n\n    print("[DEBUG] Agregando espacio de nombres...")\n    uri = "http://examples.freeopcua.github.io"\n    idx = server.register_namespace(uri)\n\n    print("[DEBUG] Creando objetos...")\n    objects = server.get_objects_node()\n\n    print("[DEBUG] Agregando variable de prueba...")\n    myvar = objects.add_variable(idx, "MyVariable", 6.7)\n    myvar.set_writable()\n\n    print("[DEBUG] Iniciando servidor...")\n    server.start()\n    print("[DEBUG] Servidor iniciado correctamente.")\n\n    try:\n        while True:\n            time.sleep(1)\n            # Puedes actualizar variable aqu\xed si quieres\n            # myvar.set_value(myvar.get_value() + 0.1)\n    except KeyboardInterrupt:\n        print("[DEBUG] Deteniendo servidor por interrupci\xf3n de teclado...")\n\n    print("[DEBUG] Parando servidor...")\n    server.stop()\n    print("[DEBUG] Servidor detenido.")\n\nexcept Exception as e:\n    print(f"[ERROR] Excepci\xf3n en servidor OPC UA: {e}")\n\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"cliente-opcua",children:"Cliente OPCUA"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from opcua import Client\n\nurl = "opc.tcp://192.168.200.1:4840/freeopcua/server/"\nclient = Client(url)\n\ntry:\n    print("Conectando cliente OPC UA...")\n    client.connect()\n    print("Cliente conectado correctamente.")\n\n    root = client.get_root_node()\n    print("Root node es:", root)\n\n    objects = client.get_objects_node()\n    print("Navegando objetos:")\n    for child in objects.get_children():\n        print("  ->", child, child.get_display_name().Text)\n\n    print("Accediendo a variable MyVariable...")\n    myvar = objects.get_child(["2:MyVariable"])  # Usa el namespace que aparece al hacer get_children\n    val = myvar.get_value()\n    print("Valor de MyVariable:", val)\n\nexcept Exception as e:\n    print(f"Error al conectar o leer: {e}")\n\nfinally:\n    client.disconnect()\n    print("Cliente desconectado")\n'})}),"\n",(0,s.jsx)(n.h2,{id:"anexo-problemas-siemens-iot20240",children:"Anexo: problemas Siemens IoT20240"}),"\n",(0,s.jsx)(n.p,{children:"Los tiempos de ejecuci\xf3n de scripts son algo elevados, scripts que en un entorno actual se ejecutan en segundos pueden llevar 3 minutos en el Yocto del Siemenes IoT2040, como en el caso del despliegue del servidor OPCUA incluido en esta entrega."}),"\n",(0,s.jsx)(n.p,{children:"Los motivos o causas de ese comportamiento se pueden clasificar acorde a las siguientes caracter\xedsticas:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Hardware limitado (microprocesador)"}),"\n",(0,s.jsx)(n.li,{children:"Python en sistemas embebidos va m\xe1s lento."}),"\n",(0,s.jsx)(n.li,{children:"Implementaci\xf3n de asyncio o sockets puede consumir mucho hardware en entornos limitados."}),"\n",(0,s.jsx)(n.li,{children:"La librer\xeda OPCUA lleva a cabo unos procesos que son costosos en consumo de hardware."}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);